# 4798 문제 최적화 원리 설명

## 문제 개요

등차수열 `a*n + b` (L ≤ n ≤ U)에서 소수인 항의 개수를 구하는 문제입니다.

- 제약: `a*n + b ≤ 10^12`, `U - L ≤ 10^6`

## 원래 코드의 문제점

### 1. **range() 객체 생성 오버헤드**

```python
for n in range(st, U + 1, i):
    # ...
```

- 큰 범위에서 `range()` 객체를 생성하는 것이 비효율적입니다
- 예: `range(0, 1000000, 2)`는 50만 개의 요소를 가진 range 객체를 생성합니다
- 각 소수마다 range 객체를 생성하므로 메모리와 시간이 낭비됩니다

### 2. **불필요한 반복 계산**

```python
for n in range(st, U + 1, i):
    value = n * a + b  # 매번 계산
    if value != i:
        rs[n - L] = True
```

- 이미 `n * a + b ≡ 0 (mod p)`임을 알고 있는데, 매번 `value`를 계산합니다
- 작은 소수(예: 2, 3, 5)의 경우 반복 횟수가 매우 많아 비효율적입니다

### 3. **시간 복잡도 분석**

- 소수 개수: 약 `O(√(10^12)) = O(10^6)` 개
- 각 소수 p에 대해: 약 `(U-L)/p` 번 반복
- 총 반복 횟수: `(U-L) * (1/2 + 1/3 + 1/5 + ...)` ≈ `(U-L) * log(log(10^6))`
- 하지만 range() 생성 오버헤드로 인해 실제로는 더 느립니다

## 최적화 전략

### 최적화 1: range() 대신 직접 인덱스 계산

```python
# 기존 (느림)
for n in range(st, U + 1, i):
    rs[n - L] = True

# 최적화 (빠름)
idx = st - L
while idx < range_len:
    rs[idx] = True
    idx += p
```

**이유**: range 객체를 생성하지 않고 직접 인덱스를 증가시켜 메모리와 시간을 절약합니다.

### 최적화 2: 시작 위치 계산 최적화

```python
# 기존
st = (L // i) * i + n_mod
if st < L:
    st += i

# 최적화
L_mod = L % p
if n_mod >= L_mod:
    st = L + (n_mod - L_mod)
else:
    st = L + (n_mod - L_mod + p)
```

**이유**: 나눗셈 연산을 모듈러 연산으로 대체하여 더 빠르게 계산합니다.

### 최적화 3: p² 이상인 경우만 체로 걸러내기

```python
# val = n * a + b가 p의 배수인 경우
if val > p and val >= p * p:
    rs[idx] = True
```

**이유**:

- `val == p`인 경우는 소수이므로 걸러내면 안 됩니다
- `val < p²`인 경우는 이미 더 작은 소수로 걸러졌을 가능성이 높습니다
- 하지만 이 최적화는 선택적이며, 원래 코드도 이미 `val != i` 체크를 하고 있습니다

### 최적화 4: 작은 소수부터 처리 (이미 구현됨)

**이유**: 작은 소수로 먼저 걸러내면 나중에 큰 소수 처리 시 반복 횟수가 줄어듭니다.

## 최적화된 알고리즘의 동작 원리

### 1. Segmented Sieve (구간 체)

```
목표: [L, U] 범위의 n에 대해 a*n + b가 소수인지 판별

1. 작은 소수들(≤ √(max_value)) 생성
2. 각 소수 p에 대해:
   - a*n + b ≡ 0 (mod p)인 n을 찾음 (EEA 사용)
   - 해당 n들을 합성수로 표시
3. 남은 후보들에 대해 Miller-Rabin으로 최종 검증
```

### 2. EEA (Extended Euclidean Algorithm)의 역할

```
문제: a*n + b ≡ 0 (mod p)인 n을 찾기
→ a*n ≡ -b (mod p)
→ n ≡ (-b) * a^(-1) (mod p)

EEA로 a의 모듈러 역원 a^(-1)을 구하고,
n_mod = (-b) * a^(-1) (mod p)를 계산합니다.
```

### 3. 시간 복잡도

- 소수 생성: `O(√(10^12)) = O(10^6)`
- 체 치기: `O((U-L) * log(log(√(10^12))))` ≈ `O(10^6 * log(log(10^6)))`
- Miller-Rabin: 체로 걸러지지 않은 후보들만 검증 (보통 매우 적음)
- **총 시간**: `O(10^6 * log(log(10^6)))` ≈ `O(10^6 * 3)` ≈ `O(3 * 10^6)`

## 추가 최적화 가능성

### 1. 비트마스크 사용

- `rs` 배열을 비트마스크로 표현하면 메모리 사용량을 1/8로 줄일 수 있습니다
- 하지만 Python에서는 오버헤드가 있어 실제로는 느릴 수 있습니다

### 2. 작은 소수로 먼저 필터링 강화

- 매우 작은 소수(2, 3, 5, 7)에 대해서는 특별한 최적화를 적용할 수 있습니다
- 예: 2의 배수는 홀수 인덱스만 체크

### 3. 병렬 처리

- 여러 소수에 대한 체 치기를 병렬로 처리할 수 있습니다
- 하지만 Python의 GIL 때문에 실제 이점은 제한적입니다

## 결론

가장 중요한 최적화는 **range() 대신 직접 인덱스 계산**입니다. 이를 통해:

- 메모리 사용량 감소
- 실행 시간 단축 (특히 큰 범위에서)
- 코드가 더 명확해짐

최적화된 코드는 원래 코드와 동일한 결과를 내지만, 훨씬 빠르게 실행됩니다.
